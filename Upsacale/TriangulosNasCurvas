
def upscaling_triangulo(image_in, sai=2):
  image_out = np.zeros((image_in.shape[0]*sai,image_in.shape[1]*sai))
  image_in = cv.copyMakeBorder(image_in, 1, 2, 1, 2, cv.BORDER_REFLECT, value=0)


  for i in range(0, image_in.shape[0]-3, 1):
    for j in range(0, image_in.shape[1]-3, 1):


      # Cria um kernel 4x4 ao redor do pixel em questÃ£o
      I, E, F, J = image_in[1+i-1,1+j-1], image_in[1+i-1,1+j], image_in[1+i-1,1+j+1], image_in[1+i-1,1+j+2]
      G, A, B, K = image_in[1+i,  1+j-1], image_in[1+i,  1+j], image_in[1+i,  1+j+1], image_in[1+i,  1+j+2]
      H, C, D, L = image_in[1+i+1,1+j-1], image_in[1+i+1,1+j], image_in[1+i+1,1+j+1], image_in[1+i+1,1+j+2]
      M, N, O, P = image_in[1+i+2,1+j-1], image_in[1+i+2,1+j], image_in[1+i+2,1+j+1], image_in[1+i+2,1+j+2]


      # coloca todos os pixels de saida iguais ao de entrada
      for v in range(0, sai, 1):
        for u in range(0, sai, 1):
          image_out[i*sai+v, j*sai+u] = A

      # Complementa as curvas (Faz um triangulo nelas)
      '''
      if(C >= B-12 and C <= B+12 and C != A and B != A):
        for v in range(0, sai, 1):
          for u in range(0, sai, 1):
            if(v >= sai-u):
              image_out[i*sai+v, j*sai+u] = np.uint8(np.floor(C + B) * 0.5)
            #else:
            #  image_out[i*sai+v, j*sai+u] = A

      if(G >= C-12 and G <= C+12 and G != A and C != A):
        for v in range(0, sai, 1):
          for u in range(0, sai, 1):
            if(v > u):
              image_out[i*sai+v, j*sai+u] = np.uint8(np.floor(G + C) * 0.5)
            #else:
            #  image_out[i*sai+v, j*sai+u] = A
     '''


      
      if(E >= B-12 and E <= B+12 and E != A and B != A):
        for v in range(0, sai, 1):
          for u in range(v, sai, 1):
            if(v < u):
              image_out[i*sai+v, j*sai+u] = np.uint8(np.floor(B + E) * 0.5)
            #else:
            #  image_out[i*sai+v, j*sai+u] = A

      if(G >= E-12 and G <= E+12 and G != A and E != A):
        for v in range(0, sai, 1):
          for u in range(0, sai, 1):
            if(v+1 < sai-u):
              image_out[i*sai+v, j*sai+u] = np.uint8(np.floor(G + E) * 0.5)
            #else:
            #  image_out[i*sai+v, j*sai+u] = A



  return image_out
